{"name":"SOLO","tagline":"Saturation physics at One Loop Order","body":"This is the program used to calculate the complete next-to-leading cross section\r\nfor inclusive hadron production in pA collisions, described in the paper\r\n\r\n> Anna M. Stasto, Bo-Wen Xiao, David Zaslavsky  \r\n> \"Towards the Test of Saturation Physics Beyond Leading Logarithm\"  \r\n> arXiv:1307.4057 [hep-ph]\r\n\r\nPlease cite this paper if you use the results of the code in a publication.\r\n\r\n# Quick start\r\n\r\nThe quickest and intended way to compile the code is as follows: first, ensure\r\nthat git, GSL and CMake are properly installed (as well as a C++ compiler; GCC\r\nis recommended). Then run the following commands:\r\n\r\n    git clone https://github.com/diazona/SOLO.git\r\n    cd SOLO\r\n    git submodule init\r\n    git submodule update\r\n    \r\nAt this point you will need to manually download the MSTW PDF interface from\r\nhttp://mstwpdf.hepforge.org/code/code.html. Extract the files `mstwpdf.cc` and\r\n`mstwpdf.h` from the tarball and place them in SOLO's `src/` directory. (We are\r\nnot authorized to distribute the MSTW PDF interface as part of SOLO, which is\r\nwhy this has to be done manually.) Then, from the directory `SOLO/` (the parent\r\ndirectory of `src/`), run these commands:\r\n    \r\n    mkdir build\r\n    cd build\r\n    cmake .. && make\r\n\r\nAt the end of this you should have a `build/` directory containing the programs.\r\n\r\nIn order to run the program, you will need two additional files:\r\n\r\n- The grid file for the MSTW 2008 PDF at NLO, from the paper\r\n    \r\n    > A. D. Martin, W. J. Stirling, R. S. Thorne and G. Watt,  \r\n    > \"Parton distributions for the LHC\",  \r\n    > Eur. Phys. J. C 63 (2009) 189-285  \r\n    > arXiv:0901.0002 [hep-ph].\r\n\r\nThe filename is `mstw2008nlo.00.dat`, and it can be downloaded as part of an\r\narchive at the MSTW PDF site http://mstwpdf.hepforge.org/code/code.html.\r\n\r\n- The data file for the DSS fragmentation functions at NLO, from the paper\r\n\r\n    > Daniel de Florian, Rodolfo Sassot, Marco Stratmann  \r\n    > \"Global analysis of fragmentation functions for pions and kaons and their uncertainties\"  \r\n    > Phys. Rev. D 75, 114010 (2007)  \r\n    > arXiv:hep-ph/0703242\r\n\r\nThe filename is `PINLO.DAT`. Unfortunately we (authors of SOLO) are not aware of\r\na website where this file is directly available.\r\n\r\n# Running\r\n\r\nThe program is invoked as\r\n\r\n    ./oneloopcalc <options>\r\n\r\nwhere the <options> can include any number of the following, in any order:\r\n\r\n- Hard factor group specifications\r\n\r\n    These tell the program which terms to calculate. A hard factor _group_\r\n    specification is made of any number of individual hard factor specifications\r\n    separated by commas. The program will calculate the results for all the\r\n    terms in the group and display a total for each group.\r\n    \r\n    An _individual_ hard factor specification is a string like \"p:h02qq\" or\r\n    \"m:h16gg\". The \"p:\" at the beginning specifies the position space\r\n    implementation, \"r:\" specifies a position space implementation with the\r\n    angular integral already done, and the \"m:\" specifies the momentum space\r\n    implementation. The prefix can be omitted, in which case position space\r\n    is taken as the default. (Not recommended, as position space is highly\r\n    inaccurate for some terms.)\r\n    \r\n    The rest of the string gives the name of a hard factor. The canonical set\r\n    of possible names that can be used with a \"p:\" prefix are all the return\r\n    values from the get_name() methods in hardfactors_position.h, and similarly\r\n    for \"r:\" with hardfactors_radial.h and \"m:\" with hardfactors_momentum.h.\r\n    Here's a near-complete list:\r\n    \r\n        p:h02qq m:h02qq p:h12qq r:h12qq p:h14qq m:h14qq\r\n        p:h02gg m:h02gg p:h12gg r:h12gg p:h12qqbar m:h12qqbar p:h16gg m:h16gg\r\n        p:h112qg r:h112qg p:h122qg r:h122qg p:h14qg m:h14qg\r\n        p:h112gq r:h112gq p:h122gq r:h122gq p:h14gq m:h14gq\r\n        \r\n    The names are case-insensitive.\r\n\r\n    It's also possible to specify the group of all leading order terms,\r\n    \r\n        m:h02qq,m:h02gg\r\n        \r\n    using the shortcut \"lo\", and the group of all next-to-leading order terms,\r\n    \r\n        r:h12qq,m:h14qq,r:h12gg,m:h12qqbar,m:h16gg,r:h112gq,r:h122gq,m:h14gq,\r\n        r:h112qg,r:h122qg,m:h14qg\r\n        \r\n    using the shortcut \"nlo\". These are defined in oneloopcalc.cpp. The default\r\n    if no hard factor groups are specified on the command line is\r\n    \r\n        lo nlo\r\n\r\n- Configuration file names\r\n\r\n    Configuration files contain parameters for the program, in the format\r\n    \r\n        key1=value1\r\n        key2=value2\r\n        \r\n    and so on. Keys are case-insensitive. The canonical list of keys which\r\n    are used is the code in context.cpp. Here's a mostly-complete list:\r\n    \r\n    - `A` (no default)\r\n\r\n        the mass number\r\n\r\n    - `abserr` (default 1e-20)\r\n\r\n        the absolute error at which to stop an integration, for strategies which\r\n        use this termination condition\r\n\r\n    - `alphas` (default 0.2)\r\n\r\n        value for the fixed coupling\r\n\r\n    - `beta` (default 11 - 2*Nf/3)\r\n\r\n        coefficient for the LO running coupling\r\n\r\n    - `c` (no default)\r\n\r\n        the centrality coefficient, 0-1\r\n\r\n    - `c0r_optimization` (default true)\r\n\r\n        if the factorization scale scheme is c0r, whether to skip calculating\r\n        terms that should be zero\r\n\r\n    - `CF` (default 1.5)\r\n\r\n        the color factor\r\n\r\n    - `coupling_type` (default fixed)\r\n\r\n        \"fixed\" or \"running\"\r\n\r\n    - `cubature_iterations`\r\n\r\n        number of calls to use for cubature integration\r\n\r\n    - `factorization_scale` (default fixed)\r\n\r\n        \"fixed\" or \"4pT2\" or \"CpT2\" or \"c0r\" to specify how to set the factorization scale\r\n\r\n    - `factorization_scale_coefficient` (no default)\r\n\r\n        if factorization_scale is \"CpT2\", this is the coefficient to multiply by `pT2` to get `mu2`\r\n\r\n    - `ff_filename` (default PINLO.DAT)\r\n\r\n        filename to read DSS FF data from\r\n\r\n    - `gammaMV`\r\n\r\n        the anomalous dimension in the MV gluon distribution\r\n\r\n    - `gdist_momentum_filename`\r\n\r\n        file to read the momentum data for a gluon distribution from\r\n\r\n    - `gdist_position_filename`\r\n\r\n        file to read the position data for a gluon distribution from\r\n\r\n    - `gdist_subinterval_limit` (default 10000)\r\n\r\n        number of subdivisions to use when integrating a position gluon distribution\r\n\r\n    - `gdist_type` (default GBW)\r\n\r\n        the type of the gluon distribution, \"GBW\", \"MV\", \"fMV\", \"file\", or \"gbw+file\"\r\n\r\n    - `hadron` (no default)\r\n\r\n        the type of hadron detected, \"pi-\", \"pi0\", or \"pi+\"\r\n\r\n    - `integration_strategy` (default VEGAS)\r\n\r\n        the integration type to use, \"MISER\", \"VEGAS\" (best), or \"QUASI\"\r\n\r\n    - `lambda` (default 0.288)\r\n\r\n        the exponent in the definition of the saturation scale\r\n\r\n    - `lambdaMV` (default 0.241)\r\n\r\n        the parameter in the MV gluon distribution, in GeV\r\n\r\n    - `lambdaQCD` (default 0.2428711 = sqrt(0.0588))\r\n\r\n        QCD lambda in GeV, used in the running coupling\r\n\r\n    - `miser_iterations` (default 10000000 = 1e7)\r\n\r\n        number of iterations to use in MISER integration\r\n\r\n    - `mu2` (default 10)\r\n\r\n        factorization scale in GeV, if factorization_scale is \"fixed\"\r\n\r\n    - `Nc` (default 3)\r\n\r\n        number of colors\r\n\r\n    - `Nf` (default 3)\r\n\r\n        number of flavors\r\n\r\n    - `pdf_filename` (default mstw2008nlo.00.dat)\r\n\r\n        filename to read MSTW PDF from\r\n\r\n    - `projectile` (no default)\r\n\r\n        the type of projectile, \"deuteron\" or \"proton\"\r\n\r\n    - `pseudorandom_generator_seed` (default 0)\r\n\r\n        seed for the GSL random number generator\r\n\r\n    - `pseudorandom_generator_type` (default mt19937)\r\n\r\n        algorithm to use for generating random numbers; allowed values are in the GSL documentation\r\n\r\n    - `pT` (no default)\r\n\r\n        comma-separated list of transverse momenta\r\n\r\n    - `quasirandom_generator_type` (default halten)\r\n\r\n        algorithm to use for generating quasirandom numbers for QMC integration;\r\n        allowed values are in the GSL documentation\r\n\r\n    - `quasi_iterations` (default 1000000)\r\n\r\n        the number of iterations at which to stop quasi Monte Carlo integration\r\n\r\n    - `regulator` (default 1)\r\n\r\n        the position of the Landau pole for the regulated LO running coupling\r\n\r\n    - `relerr` (default 0)\r\n\r\n        the relative error at which to stop an integration, for strategies which use this termination condition\r\n\r\n    - `satscale_source` (default extract from momentum)\r\n\r\n        for a file gluon distribution, how to extract the saturation scale;\r\n        allowed values are \"analytic\" (Q0²(x0/x)^λ), \"extract from momentum\"\r\n        which determines the saturation scale by finding the momentum where the\r\n        gluon distribution equals a fixed fraction of its value at a reference\r\n        momentum, and \"extract from position\" which finds the radius where the\r\n        gluon distribution equals a fixed threshold value\r\n\r\n    - `satscale_threshold` (no default)\r\n\r\n        if satscale_source is \"extract from momentum\" or\r\n        \"extract from position\", this is the fixed threshold value (or fraction\r\n        of its value at a reference point, in the momentum case) that the gluon\r\n        distribution should equal at the saturation scale\r\n\r\n    - `Sperp` (default 1)\r\n\r\n        cross-sectional area of the hadron\r\n\r\n    - `sqs` (no default)\r\n\r\n        sqrt(s), the collider's CM energy\r\n\r\n    - `TR` (default 0.5)\r\n\r\n        group coefficient\r\n\r\n    - `vegas_incremental_iterations` (default 1000000)\r\n\r\n        number of function evaluations to use in each step of the VEGAS Monte Carlo algorithm after the first\r\n\r\n    - `vegas_initial_iterations` (default 100000)\r\n\r\n        number of function evaluations to use to refine the grid in the first step of the VEGAS algorithm\r\n\r\n    - `x0` (default 0.000304)\r\n\r\n        the fit parameter from the definition of the saturation scale\r\n\r\n    - `Y` (no default)\r\n\r\n        comma-separated list of rapidities to calculate at\r\n\r\n    The configuration files have to at least set `A`, `c`, `sqs`, and `Y`, and also `pT` if no transverse momenta are specified as command line arguments.\r\n        \r\n- Transverse momentum values\r\n\r\n    Any numbers given as command line arguments are put together into one big\r\n    list of transverse momentum values to run the calculation at. If a\r\n    comma-separated list of numbers is given, then it will be split apart and\r\n    each number added to the one big list. There's no significance to putting\r\n    certain pT values together and others not. (`0.5 0.7 0.8,0.9` and\r\n    `0.5,0.7 0.8 0.9` are exactly equivalent.) Any `pT` values specified on the\r\n    command line will _replace_ `pT` values specified in the config file, if there\r\n    is one.\r\n\r\n- Literal options\r\n\r\n    --separate  Print out the results for each individual hard factor, not just\r\n                the total for each hard factor groups\r\n    --minmax    Track and print out the minimum and maximum values of kinematic\r\n                variables\r\n    --trace-gdist\r\n                Print out parameters and values for every call to the gluon\r\n                distribution. Output goes to the file trace_gdist.output in the\r\n                working directory. (Expect this file to grow to several hundred\r\n                megabytes.)\r\n    --trace=var1,var2,...\r\n                Print out selected variables from the integration context after\r\n                every single evaluation of the function. The output goes to the\r\n                file trace.output in the working directory. (Expect this file to\r\n                grow to several megabytes.) The allowable variables are those\r\n                in ictx_var_list.inc, or you can use \"--trace=all\" or\r\n                \"--trace=*\" to print out all available variables.\r\n\r\n\r\n# Structure\r\n\r\nBasically the code runs as follows:\r\n\r\n1. Collect the command line options and settings from configuration files and\r\n   put everything into a `ResultsCalculator`\r\n2. For each combination of `pT` and `Y`, and for each hard factor group:\r\n    a. Create an `Integrator` with the current values of `pT` and `Y` and the current\r\n       hard factor group\r\n    b. The `Integrator` calls the GSL Monte Carlo integration routine\r\n    c. For each time the MC routine evaluates the function\r\n        i.  Update the variables in the `IntegrationContext`\r\n        ii. Go through the list of `HardFactor` instances in the current group\r\n            and get a value from each one\r\n        iii.Return the total value\r\n    d. Store the value and error bound returned from the Monte Carlo\r\n3. Print out all the results\r\n\r\n\r\n# Files\r\n\r\nSource code for the program itself:\r\n\r\n- `oneloopcalc.cpp`\r\n\r\n    Main program\r\n\r\n- `log.h`\r\n\r\n    Declares an output stream to write status messages to\r\n\r\n- `gsl_exception.h`\r\n\r\n    Declares an exception to be thrown when GSL reports an error\r\n\r\n- `hardfactors.h`\r\n\r\n    A class that abstractly represents a hard factor (i.e. an expression to be integrated)\r\n\r\n- `hardfactors_momentum.h`  \r\n  `hardfactors_momentum.cpp`\r\n\r\n    Implementation of the momentum space hard factors (terms)\r\n\r\n- `hardfactors_position.h`  \r\n  `hardfactors_position.cpp`\r\n\r\n    Implementation of the position space hard factors (terms)\r\n\r\n- `gluondist.h`  \r\n  `gluondist.cpp`\r\n\r\n    Implementations of the gluon distributions\r\n\r\n- `gluondist_driver.cpp`\r\n\r\n    A program to print out values from the gluon distributions\r\n\r\n- `coupling.h`  \r\n  `coupling.cpp`\r\n\r\n    Implementations of the fixed and LO running couplings\r\n\r\n- `factorizationscale.h`  \r\n  `factorizationscale.cpp`\r\n\r\n    Implementations of the various schemes for the factorization scale\r\n\r\n- `integrationcontext.h`  \r\n  `integrationcontext.cpp`\r\n\r\n    A class that stores the kinematic variables used in the calculation. The\r\n    values stored in this get updated every time the function is evaluated.\r\n\r\n- `integrator.h`  \r\n  `integrator.cpp`\r\n\r\n    A class that stores the parameters for the integral and actually calls the\r\n    GSL Monte Carlo integration functions\r\n\r\n- `integrationtype.h`  \r\n  `integrationtype.cpp`\r\n\r\n    Definitions of integration types. An integration type specifies how many\r\n    dimensions are in the Monte Carlo integral and what the limits are.\r\n\r\n- `utils.h`  \r\n  `utils.cpp`\r\n\r\n    Some string and list processing functions\r\n\r\n- `ictx_var_list.inc`\r\n\r\n    Variables from the integration context, listed in a separate file as a\r\n    preprocessor hack of sorts\r\n\r\nSource code and object code for other things used by the program:\r\n    \r\n- `dss_pinlo.h`  \r\n  `dss_pinlo.cpp`\r\n\r\n    A C++ interface to the DSS fragmentation functions\r\n\r\n- `dss_pinlo_test.cpp`\r\n\r\n    Test program for the DSS FF interface\r\n\r\n- `interp2d.h`  \r\n  `libinterp2d.a`\r\n\r\n    A 2D interpolation library compatible with the GSL\r\n    Full source code at https://github.com/diazona/interp2d\r\n\r\n- `quasimontecarlo.h`  \r\n  `libquasimontecarlo.a`\r\n\r\n    A library for quasi Monte Carlo integration compatible with the GSL\r\n    Full source code at https://github.com/diazona/quasimontecarlo\r\n\r\nSource code for other things used by the program, written by other people:\r\n    \r\n- `mstwpdf.h`  \r\n  `mstwpdf.cc`\r\n\r\n    A C++ interface to the MSTW PDFs\r\n\r\n- `cubature.h`  \r\n  `cubature.c`\r\n\r\n    A library for multidimensional cubature (deterministic integration)\r\n    Not currently used\r\n\r\nNon-source code files:\r\n    \r\n- `CMakeFiles.txt`\r\n\r\n    Instructions for the build system, CMake\r\n\r\n- `PINLO.DAT`\r\n\r\n    DSS fragmentation function data\r\n\r\n- `pinlo_extended.dat`\r\n\r\n    DSS fragmentation function data with extrapolation to lower z (the\r\n    significance of this file will be described in an upcoming long paper\r\n    about SOLO)\r\n\r\n- `mstw2008nlo.00.dat`\r\n\r\n    MSTW PDF data\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}